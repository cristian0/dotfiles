# Create a new directory and enter it
function md() {
	mkdir -p "$@" && cd "$@"
}


# find shorthand
function f() {
    find . -name "$1"
}


# cd into whatever is the forefront Finder window.
cdf() {  # short for cdfinder
  cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}


# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}"
	open "http://localhost:${port}/"
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesnâ€™t break anything for binary files)
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}


# Copy w/ progress
cp_p () {
  rsync -WavP --human-readable --progress $1 $2
}


# Syntax-highlight JSON strings or files
function json() {
	if [ -p /dev/stdin ]; then
		# piping, e.g. `echo '{"foo":42}' | json`
		python -mjson.tool | pygmentize -l javascript
	else
		# e.g. `json '{"foo":42}'`
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	fi
}




# get gzipped size
function gz() {
	echo "orig size    (bytes): "
	cat "$1" | wc -c
	echo "gzipped size (bytes): "
	gzip -c "$1" | wc -c
}

# whois a domain or a URL
function whois() {
	local domain=$(echo "$1" | awk -F/ '{print $3}') # get domain from URL
	if [ -z $domain ] ; then
		domain=$1
	fi
	echo "Getting whois record for: $domain â€¦"

	# avoid recursion
					# this is the best whois server
													# strip extra fluff
	/usr/bin/whois -h whois.internic.net $domain | sed '/NOTICE:/q'
}



# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc
function extract() {
	if [ -f "$1" ] ; then
		local filename=$(basename "$1")
		local foldername="${filename%%.*}"
		local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
		local didfolderexist=false
		if [ -d "$foldername" ]; then
			didfolderexist=true
			read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
			echo
			if [[ $REPLY =~ ^[Nn]$ ]]; then
				return
			fi
		fi
		mkdir -p "$foldername" && cd "$foldername"
		case $1 in
			*.tar.bz2) tar xjf "$fullpath" ;;
			*.tar.gz) tar xzf "$fullpath" ;;
			*.tar.xz) tar Jxvf "$fullpath" ;;
			*.tar.Z) tar xzf "$fullpath" ;;
			*.tar) tar xf "$fullpath" ;;
			*.taz) tar xzf "$fullpath" ;;
			*.tb2) tar xjf "$fullpath" ;;
			*.tbz) tar xjf "$fullpath" ;;
			*.tbz2) tar xjf "$fullpath" ;;
			*.tgz) tar xzf "$fullpath" ;;
			*.txz) tar Jxvf "$fullpath" ;;
			*.zip) unzip "$fullpath" ;;
			*) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}

# who is using the laptop's iSight camera?
camerausedby() {
    echo "Checking to see who is using the iSight cameraâ€¦ ðŸ“·"
    usedby=$(lsof | grep -w "AppleCamera\|USBVDC\|iSight" | awk '{printf $2"\n"}' | xargs ps)
    echo -e "Recent camera uses:\n$usedby"
}


# animated gifs from any video
# from alex sexton   gist.github.com/SlexAxton/4989674
gifify() {
  if [[ -n "$1" ]]; then
    if [[ $2 == '--good' ]]; then
      ffmpeg -i $1 -r 10 -vcodec png out-static-%05d.png
      time convert -verbose +dither -layers Optimize -resize 900x900\> out-static*.png  GIF:- | gifsicle --colors 128 --delay=5 --loop --optimize=3 --multifile - > $1.gif
      rm out-static*.png
    else
      ffmpeg -i $1 -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > $1.gif
    fi
  else
    echo "proper usage: gifify <input_movie.mov>. You DO need to include extension."
  fi
}

# turn that video into webm.
# brew reinstall ffmpeg --with-libvpx
webmify(){
	ffmpeg -i $1 -vcodec libvpx -acodec libvorbis -isync -copyts -aq 80 -threads 3 -qmax 30 -y $2 $1.webm
}

function docker-bash {
    docker exec -it $1 bash
}

# Eboox Code aliases

v() {
  cd ~/code/OSXContainerHost
	vagrant $@
	cd - > /dev/null
}

dc() {
  cd ~/code/docker
	docker-compose $@
	cd - > /dev/null
}

docker-ip() {
	docker inspect -f '{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(docker ps -q)
}

oaproxy() {
	site=$1
	token=$2
	secret=$3

	if [ $site == "list" ]; then
		ps auxwww | grep -v grep | grep oauth-proxy
		return
	fi

	if [ $site == "killall" ]; then
		ps auxwww | grep node.*oauth | grep -v grep  | awk '{print $2}' | while read -r proc ; do
				kill $proc
				echo "$proc killed"
			done
		return
	fi

	if [ $site == "mr" ]; then
	  consumer_key="rjq0jhhhfaducgjam40ggpmm86my6mpq"
	  consumer_secret="4d08w8847rdee4autw2jpchhjctumycc"
	  port="8002"
	fi

	if [ $site == "wp" ]; then
	  consumer_key="73950677305016d2831f07defe0ed9aa"
	  consumer_secret="627c5fbbb579b313874ca5a3d8ac8979"
		port="8003"
	fi

	if [ -z $consumer_key ]; then
		echo "$site non mappato."
		return
	fi

	if [ $token == "kill" ]; then
		proc=$(ps auxwww | grep oauth | grep $port | awk '{print $2}')
		if [ -z $proc ]; then
			echo "$site proxy not found"
			return
		fi
		kill $proc
		echo "$proc killed"
		return
	fi

	command="oauth-proxy -p $port --consumer-key $consumer_key --consumer-secret $consumer_secret --token $token --token-secret $secret &"
	eval $command
	echo "use for $site : http --proxy=http:\\\\localhost:$port"
}

transfer() {
    # write to output to tmpfile because of progress bar
    tmpfile=$( mktemp -t transferXXX )
    curl --progress-bar --upload-file $1 https://transfer.sh/$(basename $1) >> $tmpfile;
    cat $tmpfile;
    rm -f $tmpfile;
}

newrelic_deploy() {

  local NEWRELIC_APP_ID="2227829"
  local NEWRELIC_APIKEY="45ac388fc356c40bcebc78f7c55a4bd37fec399e9ef9b3d"
  local NEWRELIC_DEPLOY_USER="cristiano"

  local NEWRELIC_DEPLOY_REV=$1
  shift
  local NEWRELIC_DEPLOY_DESC=$@

  curl -X POST "https://api.newrelic.com/v2/applications/${NEWRELIC_APP_ID}/deployments.json" \
       -H "X-Api-Key:${NEWRELIC_APIKEY}" -i \
       -H "Content-Type: application/json" \
       -d \
  "{
    \"deployment\": {
      \"revision\": \"${NEWRELIC_DEPLOY_REV}\",
      \"description\": \"${NEWRELIC_DEPLOY_DESC}\",
      \"user\": \"${NEWRELIC_DEPLOY_USER}\"
    }
  }"

  echo "
====================================
New Relic deploy tracking sent:
Revision: $NEWRELIC_DEPLOY_REV
Description: $NEWRELIC_DEPLOY_DESC
User: $NEWRELIC_DEPLOY_USER
====================================

"
}
